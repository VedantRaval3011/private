/**
 * COA XML Parser
 * Handles parsing of BULK and FINISH stage pharmaceutical XML files
 * Generated by Oracle Reports (FGANLCERT/FGANLCERTQA format)
 */

import { parseStringPromise } from 'xml2js';
import { XMLParser } from 'fast-xml-parser';
import crypto from 'crypto';
import type {
  BulkStageData,
  FinishStageData,
  COARecord,
  COAStage,
  TestParameter,
  AssayResult,
  IdentificationTest,
  CriticalParameter,
  RelatedSubstance,
  QASignature,
} from '@/types/coa';

// ============================================
// Drug Name Mapping (Pharmaceutical-Compliant)
// ============================================

/**
 * Mapping of drug names to their salt and equivalent base forms
 * Used for proper pharmaceutical naming: SALT_NAME E.Q. BASE_NAME
 */
export const DRUG_NAME_MAP: Record<string, { salt: string; equivalent: string }> = {
  'DORZOLAMIDE': {
    salt: 'Dorzolamide Hydrochloride',
    equivalent: 'Dorzolamide'
  },
  'TIMOLOL': {
    salt: 'Timolol Maleate',
    equivalent: 'Timolol'
  },
  'CEPHALEXIN': {
    salt: 'Cephalexin',
    equivalent: 'Cephalexin'
  },
  'NEOMYCIN': {
    salt: 'Neomycin Sulphate',
    equivalent: 'Neomycin'
  },
  'PREDNISOLONE': {
    salt: 'Prednisolone Acetate',
    equivalent: 'Prednisolone'
  },
  'DEXAMETHASONE': {
    salt: 'Dexamethasone Sodium Phosphate',
    equivalent: 'Dexamethasone'
  },
  'OFLOXACIN': {
    salt: 'Ofloxacin',
    equivalent: 'Ofloxacin'
  },
  'CIPROFLOXACIN': {
    salt: 'Ciprofloxacin Hydrochloride',
    equivalent: 'Ciprofloxacin'
  },
  'MOXIFLOXACIN': {
    salt: 'Moxifloxacin Hydrochloride',
    equivalent: 'Moxifloxacin'
  },
  'BRIMONIDINE': {
    salt: 'Brimonidine Tartrate',
    equivalent: 'Brimonidine'
  },
  'LATANOPROST': {
    salt: 'Latanoprost',
    equivalent: 'Latanoprost'
  },
};

/**
 * Gets the proper pharmaceutical name format for a compound
 * Returns format: "SALT_NAME E.Q. BASE_NAME" or original if not found
 */
export function formatAssayCompoundName(rawName: string): string {
  const upperName = rawName.toUpperCase().trim();
  
  // Check if the name already contains E.Q. - if so, return as-is (properly formatted)
  if (upperName.includes('E.Q.')) {
    return rawName.trim();
  }
  
  // Try to find a matching drug in our map
  for (const [key, value] of Object.entries(DRUG_NAME_MAP)) {
    if (upperName.includes(key)) {
      // If the raw name already contains both salt and base indicators, format properly
      if (upperName.includes('HYDROCHLORIDE') || upperName.includes('MALEATE') || 
          upperName.includes('SULPHATE') || upperName.includes('ACETATE') ||
          upperName.includes('PHOSPHATE') || upperName.includes('TARTRATE')) {
        return `${value.salt} E.Q. ${value.equivalent}`;
      }
      // If it's just the base name, return the proper format
      return `${value.salt} E.Q. ${value.equivalent}`;
    }
  }
  
  // Return original if no mapping found
  return rawName.trim();
}

/**
 * Check if a test name or result is related to impurities/related substances
 * These should NOT be in assay results
 */
function isRelatedSubstanceTest(testName: string, result?: string): boolean {
  const upperName = testName.toUpperCase();
  const upperResult = (result || '').toUpperCase();
  
  // Check test name for impurity indicators
  const nameHasImpurity = (
    upperName.includes('IMPURITY') ||
    upperName.includes('SECONDARY PEAK') ||
    upperName.includes('SUM OF') ||
    upperName.includes('ANY OTHER') ||
    upperName.includes('RELATED') ||
    upperName.includes('DEGRADATION')
  );
  
  // Check result for impurity indicators (critical for compound headers like "DORZOLAMIDE")
  const resultHasImpurity = (
    upperResult.includes('IMPURITY') ||
    upperResult.includes('SECONDARY PEAK') ||
    upperResult.includes('SUM OF') ||
    upperResult.includes('ANY OTHER')
  );
  
  return nameHasImpurity || resultHasImpurity;
}

/**
 * Check if a test represents actual assay data (% content)
 * Assay data typically has percentage results and should NOT contain impurity data
 */
function isAssayData(testName: string, result: string): boolean {
  const upperName = testName.toUpperCase();
  const upperResult = result.toUpperCase();
  
  // If it contains impurity-related terms in name OR result, it's NOT assay data
  if (isRelatedSubstanceTest(testName, result)) {
    return false;
  }
  
  // Assay results should be numeric percentages, not text with "ND" or impurity listings
  // Check if result looks like impurity data (has multiple colons indicating key:value pairs)
  const colonCount = (result.match(/:/g) || []).length;
  if (colonCount >= 2) {
    // Multiple key:value pairs suggest impurity listing, not assay
    return false;
  }
  
  // Assay results typically contain percentage values in a simple format
  const hasAssayPercentage = /\d+\.?\d*\s*%/.test(result) || 
                              upperResult.includes('% W/V') ||
                              /\d+\.?\d*\s*%\s*i\.?e\.?/i.test(result);
                        
  // Check if it's a known active ingredient
  const isKnownActive = ['DORZOLAMIDE', 'TIMOLOL', 'CEPHALEXIN', 'NEOMYCIN', 
                         'PREDNISOLONE', 'DEXAMETHASONE', 'OFLOXACIN', 
                         'CIPROFLOXACIN', 'MOXIFLOXACIN', 'BRIMONIDINE', 
                         'LATANOPROST'].some(drug => upperName.includes(drug));
  
  return hasAssayPercentage && isKnownActive;
}

// ============================================
// Helper Functions
// ============================================

/**
 * Safely extract a value from XML object
 */
function safeGet(obj: unknown, path: string[], defaultValue: string = ''): string {
  try {
    let current: unknown = obj;
    for (const key of path) {
      if (current === null || current === undefined) return defaultValue;
      if (typeof current === 'object' && current !== null) {
        current = (current as Record<string, unknown>)[key];
      } else {
        return defaultValue;
      }
    }
    
    if (Array.isArray(current)) {
      current = current[0];
    }
    
    if (typeof current === 'object' && current !== null) {
      if ('_' in current) {
        return String((current as Record<string, unknown>)['_']).trim();
      }
      return defaultValue;
    }
    
    return current !== null && current !== undefined ? String(current).trim() : defaultValue;
  } catch {
    return defaultValue;
  }
}

/**
 * Find a value case-insensitively in an object
 */
function findValueCI(obj: unknown, keys: string[], defaultValue: string = ''): string {
  if (!obj || typeof obj !== 'object') return defaultValue;
  
  const record = obj as Record<string, unknown>;
  const objKeys = Object.keys(record);
  
  for (const searchKey of keys) {
    const foundKey = objKeys.find(k => k.toLowerCase() === searchKey.toLowerCase());
    if (foundKey) {
      let value = record[foundKey];
      if (Array.isArray(value)) value = value[0];
      if (typeof value === 'string') return value.trim();
      if (typeof value === 'number') return String(value);
    }
  }
  return defaultValue;
}

/**
 * Get nested G_1 data from Oracle Reports XML structure
 */
function getG1Data(data: unknown): unknown {
  if (!data || typeof data !== 'object') return null;
  
  const record = data as Record<string, unknown>;
  const paths = [
    ['LIST_G_1', 'G_1'],
    ['list_g_1', 'g_1'],
  ];
  
  for (const path of paths) {
    let current: unknown = record;
    for (const key of path) {
      if (current && typeof current === 'object') {
        const currentRecord = current as Record<string, unknown>;
        const foundKey = Object.keys(currentRecord).find(k => k.toLowerCase() === key.toLowerCase());
        if (foundKey) {
          current = currentRecord[foundKey];
          if (Array.isArray(current)) {
            current = current[0];
          }
        } else {
          current = null;
          break;
        }
      }
    }
    if (current) return current;
  }
  
  return null;
}

/**
 * Get test parameters from LIST_G_SRNO1 structure
 */
function getTestGroups(g1Data: unknown): unknown[] {
  if (!g1Data || typeof g1Data !== 'object') return [];
  
  const g1 = g1Data as Record<string, unknown>;
  let listSrno = g1['LIST_G_SRNO1'] as Record<string, unknown> | Array<unknown>;
  
  if (!listSrno) {
    const key = Object.keys(g1).find(k => k.toLowerCase() === 'list_g_srno1');
    if (key) listSrno = g1[key] as Record<string, unknown> | Array<unknown>;
  }
  
  if (!listSrno) return [];
  
  let groups: unknown[] = [];
  if (Array.isArray(listSrno)) {
    groups = listSrno;
  } else {
    const gSrno = listSrno['G_SRNO1'];
    if (Array.isArray(gSrno)) {
      groups = gSrno;
    } else if (gSrno) {
      groups = [gSrno];
    }
  }
  
  return groups;
}

/**
 * Get individual test parameters from G_SRNO1/LIST_G_2/G_2
 */
function getTestDetails(group: unknown): unknown[] {
  if (!group || typeof group !== 'object') return [];
  
  const gRecord = group as Record<string, unknown>;
  let listG2 = gRecord['LIST_G_2'] as Record<string, unknown> | Array<unknown>;
  
  if (!listG2) {
    const key = Object.keys(gRecord).find(k => k.toLowerCase() === 'list_g_2');
    if (key) listG2 = gRecord[key] as Record<string, unknown> | Array<unknown>;
  }
  
  if (!listG2) return [];
  
  let details: unknown[] = [];
  if (Array.isArray(listG2)) {
    details = listG2;
  } else {
    const g2 = listG2['G_2'];
    if (Array.isArray(g2)) {
      details = g2;
    } else if (g2) {
      details = [g2];
    }
  }
  
  return details;
}

/**
 * Get QA footer data from LIST_Q_FOOTER
 */
function getQAFooter(rootData: unknown): QASignature {
  const defaultQA: QASignature = { preparedBy: '', reviewedBy: '', signDate: '' };
  if (!rootData || typeof rootData !== 'object') return defaultQA;
  
  const record = rootData as Record<string, unknown>;
  let listFooter = record['LIST_Q_FOOTER'] as Record<string, unknown> | Array<unknown>;
  
  if (!listFooter) {
    const key = Object.keys(record).find(k => k.toLowerCase() === 'list_q_footer');
    if (key) listFooter = record[key] as Record<string, unknown> | Array<unknown>;
  }
  
  if (!listFooter) return defaultQA;
  
  let footerElements: unknown[] = [];
  if (Array.isArray(listFooter)) {
    footerElements = listFooter;
  } else {
    const qFooter = listFooter['Q_FOOTER'];
    if (Array.isArray(qFooter)) {
      footerElements = qFooter;
    } else if (qFooter) {
      footerElements = [qFooter];
    }
  }
  
  // Parse footer entries (typically: Analyst, blank entries, Q.C. Incharge)
  let preparedBy = '';
  let reviewedBy = '';
  
  for (const footer of footerElements) {
    if (!footer || typeof footer !== 'object') continue;
    const fRecord = footer as Record<string, unknown>;
    const title = findValueCI(fRecord, ['TITLE'], '').toLowerCase();
    const name = findValueCI(fRecord, ['NAME', 'CF_NAME'], '');
    
    if (title.includes('analyst')) {
      preparedBy = name || 'Analyst';
    } else if (title.includes('incharge') || title.includes('manager')) {
      reviewedBy = name || 'Q.C. Incharge';
    }
  }
  
  return { preparedBy, reviewedBy, signDate: '' };
}

/**
 * Heals malformed or incomplete XML by appending missing closing tags.
 * Specific to Oracle Reports XML structures.
 */
export function healXmlContent(xmlContent: string): string {
  if (!xmlContent || xmlContent.trim() === '') return xmlContent;
  
  let healed = xmlContent.trim();
  
  // Stack to track open tags
  const stack: string[] = [];
  
  // Regex to find opening and closing tags
  const tagRegex = /<(\/?)([a-zA-Z0-9_]+)(?:\s|\/?>|$)/g;
  let match;
  
  while ((match = tagRegex.exec(healed)) !== null) {
    const isClosing = match[1] === '/';
    const tagName = match[2];
    const fullTagMatch = match[0];
    
    // Skip XML declarations, comments, and CDATA
    if (tagName.toLowerCase() === 'xml' || tagName.startsWith('!') || tagName.startsWith('?')) {
      continue;
    }
    
    if (isClosing) {
      // Find the most recent matching tag in the stack
      const lastIndex = stack.lastIndexOf(tagName);
      if (lastIndex !== -1) {
        stack.splice(lastIndex);
      }
    } else {
      // Opening tag
      if (!fullTagMatch.includes('/>')) {
        stack.push(tagName);
      }
    }
  }
  
  // Close any remaining open tags in reverse order
  while (stack.length > 0) {
    const tagToClose = stack.pop();
    healed += `</${tagToClose}>`;
  }
  
  return healed;
}

// ============================================
// Stage Detection
// ============================================

export type DetectedStage = {
  stage: COAStage;
  method: 'filename' | 'root_tag' | 'process_tag';
};

/**
 * Detect if XML is BULK or FINISH based on multiple indicators
 */
export function detectStage(xmlContent: string, filename?: string): DetectedStage {
  // Method 1: Check filename pattern
  if (filename) {
    const upperFilename = filename.toUpperCase();
    if (upperFilename.includes('_BULK')) {
      return { stage: 'BULK', method: 'filename' };
    }
    if (upperFilename.includes('_FINISH')) {
      return { stage: 'FINISH', method: 'filename' };
    }
  }
  
  // Method 2: Check root XML tag
  const rootTagMatch = xmlContent.match(/<(FGANLCERT|FGANLCERTQA)[>\s]/i);
  if (rootTagMatch) {
    const tag = rootTagMatch[1].toUpperCase();
    if (tag === 'FGANLCERT') {
      return { stage: 'BULK', method: 'root_tag' };
    }
    if (tag === 'FGANLCERTQA') {
      return { stage: 'FINISH', method: 'root_tag' };
    }
  }
  
  // Method 3: Check PROCESS tag value
  const processMatch = xmlContent.match(/<PROCESS>(\w+)<\/PROCESS>/i);
  if (processMatch) {
    const process = processMatch[1].toUpperCase();
    if (process === 'BULK') {
      return { stage: 'BULK', method: 'process_tag' };
    }
    // FINISH files may not have PROCESS tag, or have different value
  }
  
  // Default to FINISH if root tag is FGANLCERTQA pattern
  if (xmlContent.includes('FGANLCERTQA')) {
    return { stage: 'FINISH', method: 'root_tag' };
  }
  
  // Fallback: assume BULK if has FGANLCERT
  return { stage: 'BULK', method: 'root_tag' };
}

// ============================================
// Test Parameter Classification
// ============================================

type TestCategory = 'description' | 'ph' | 'assay' | 'identification' | 'sterility' | 
                    'uniformity' | 'capping' | 'related_substances' | 'other';

function classifyTest(testName: string): TestCategory {
  const upper = testName.toUpperCase();
  
  if (upper === 'DESCRIPTION') return 'description';
  if (upper === 'PH') return 'ph';
  if (upper.includes('ASSAY')) return 'assay';
  if (upper.includes('IDENTIFICATION')) return 'identification';
  if (upper.includes('STERILITY')) return 'sterility';
  if (upper.includes('UNIFORMITY')) return 'uniformity';
  if (upper.includes('CAPPING')) return 'capping';
  if (upper.includes('RELATED SUBSTANCES') || upper.includes('IMPURITY')) return 'related_substances';
  
  return 'other';
}

/**
 * Check if result complies with limits
 */
function checkCompliance(result: string, limits: string): boolean {
  // Simple compliance check - if result contains "Complies" or specific pass keywords
  const upperResult = result.toUpperCase();
  if (upperResult.includes('COMPLIES') || upperResult.includes('PASS')) return true;
  if (upperResult.includes('FAIL') || upperResult.includes('NOT DETECTED')) return true; // ND is typically compliant for impurities
  
  // For numeric limits, try to parse
  // Example: limits = "5.0 to 6.0", result = "5.54"
  const rangeMatch = limits.match(/(\d+\.?\d*)\s*to\s*(\d+\.?\d*)/i);
  if (rangeMatch) {
    const min = parseFloat(rangeMatch[1]);
    const max = parseFloat(rangeMatch[2]);
    const numResult = parseFloat(result.replace(/[^\d.]/g, ''));
    if (!isNaN(numResult) && !isNaN(min) && !isNaN(max)) {
      return numResult >= min && numResult <= max;
    }
  }
  
  // For NMT (Not More Than) limits
  const nmtMatch = limits.match(/NMT\s*(\d+\.?\d*)/i);
  if (nmtMatch) {
    const max = parseFloat(nmtMatch[1]);
    const numResult = parseFloat(result.replace(/[^\d.]/g, ''));
    if (!isNaN(numResult) && !isNaN(max)) {
      return numResult <= max;
    }
    // "ND" (Not Detected) is always compliant for NMT
    if (upperResult.includes('ND') || upperResult.includes('NOT DETECTED')) {
      return true;
    }
  }
  
  // Default to true if we can't parse
  return true;
}

// ============================================
// BULK Data Extraction
// ============================================

function extractBulkData(g1Data: unknown, rootData: unknown): BulkStageData {
  const g1 = g1Data as Record<string, unknown>;
  
  // Basic info
  const batchNumber = findValueCI(g1, ['BATCH', 'BATCH1'], '');
  const arNumber = findValueCI(g1, ['FGARNO'], '');
  const testNumber = findValueCI(g1, ['FGTESTNO'], '');
  const testDate = findValueCI(g1, ['FGTESTDT'], '');
  
  // Product info
  const productName = findValueCI(g1, ['ITMNAME', 'ITMDETAIL', 'CF_ITMNM'], '');
  const productCode = findValueCI(g1, ['ITMCODE'], '');
  const genericName = findValueCI(g1, ['GENERICNM'], '');
  
  // Manufacturing details
  const manufacturer = findValueCI(g1, ['MAKE'], '');
  const mfgLicenseNo = findValueCI(g1, ['MFGLICNO'], '');
  const batchSize = findValueCI(g1, ['BATBATCHSIZE', 'BATCHSIZE'], '');
  const mfgDate = findValueCI(g1, ['MFGDT'], '');
  const expDate = findValueCI(g1, ['EXPDT'], '');
  const specification = findValueCI(g1, ['SPEC', 'SPEC1'], '');
  
  // Extract test parameters
  const testParameters: TestParameter[] = [];
  const assayResults: AssayResult[] = [];
  let description = '';
  
  const testGroups = getTestGroups(g1Data);
  let srNo = 1;
  
  for (const group of testGroups) {
    const details = getTestDetails(group);
    
    for (const detail of details) {
      if (!detail || typeof detail !== 'object') continue;
      const dRecord = detail as Record<string, unknown>;
      
      const testName = findValueCI(dRecord, ['PROTEST1'], '');
      const limits = findValueCI(dRecord, ['LIMITS1'], '');
      const result = findValueCI(dRecord, ['RESULT'], '');
      
      if (!testName || testName === '.') continue;
      
      const category = classifyTest(testName);
      const complies = checkCompliance(result, limits);
      
      // Handle description specially
      if (category === 'description') {
        description = result;
      }
      
      // Skip impurity/related substances data - these should NOT be in assay
      if (isRelatedSubstanceTest(testName, result)) {
        // Add as regular test parameter (BULK doesn't have separate relatedSubstances)
        testParameters.push({
          srNo: srNo++,
          name: testName,
          limits,
          result,
          complies,
        });
        continue;
      }
      
      // Handle assay results - only if it's actual assay data with % results
      if (isAssayData(testName, result)) {
        // Parse assay limits (e.g., "95.0 % to 105.0 %")
        const limitMatch = limits.match(/(\d+\.?\d*)\s*%?\s*to\s*(\d+\.?\d*)\s*%?/i);
        
        // Get proper pharmaceutical name with E.Q. format
        const baseCompoundName = testName.toUpperCase().startsWith('ASSAY') 
          ? testName.replace(/ASSAY/i, '').trim() || 'Active'
          : testName;
        const properCompoundName = formatAssayCompoundName(baseCompoundName);

        assayResults.push({
          compound: properCompoundName,
          limitMin: limitMatch ? `${limitMatch[1]}%` : '',
          limitMax: limitMatch ? `${limitMatch[2]}%` : '',
          specification: limits, // Full specification text (may include w/v range)
          result: result,
          resultAlt: result.includes('\n') ? result.split('\n')[1]?.trim() : undefined,
          complies,
        });
      } else if (category !== 'description') {
        // Regular test parameter
        testParameters.push({
          srNo: srNo++,
          name: testName,
          limits,
          result,
          complies,
        });
      }
    }
  }
  
  // Get QA info
  const qaData = getQAFooter(rootData);
  const analystName = findValueCI(g1, ['ANALYSTNAME'], '');
  const analystDate = findValueCI(g1, ['ANALIST_DATE'], '');
  
  return {
    batchNumber,
    arNumber,
    testNumber,
    testDate,
    productName,
    productCode,
    genericName,
    description,
    manufacturer,
    mfgLicenseNo,
    batchSize,
    mfgDate,
    expDate,
    specification,
    testParameters,
    assayResults,
    remarks: findValueCI(g1, ['FGRMK'], ''),
    analystName,
    analystDate,
    qaData,
    status: findValueCI(g1, ['STATUS'], ''),
  };
}

// ============================================
// FINISH Data Extraction
// ============================================

function extractFinishData(g1Data: unknown, rootData: unknown): FinishStageData {
  const g1 = g1Data as Record<string, unknown>;
  
  // Basic info (FINISH files may use BATCH1 instead of BATCH)
  const batchNumber = findValueCI(g1, ['BATCH1', 'BATCH'], '');
  const arNumber = findValueCI(g1, ['FGARNO'], '');
  const testNumber = findValueCI(g1, ['FGTESTNO'], '');
  const testDate = findValueCI(g1, ['FGTESTDT'], '');
  
  // Product info
  const productName = findValueCI(g1, ['ITMNAME', 'ITMDETAIL', 'CF_ITMNM'], '');
  const productCode = findValueCI(g1, ['ITMCODE'], '');
  const genericName = findValueCI(g1, ['GENERICNM'], '');
  
  // Manufacturing details
  const manufacturer = findValueCI(g1, ['MAKE'], '');
  const mfgLicenseNo = findValueCI(g1, ['MFGLICNO'], '');
  const batchSize = findValueCI(g1, ['ACTUALBATCHSIZE', 'BATCHSIZE'], '');
  const mfgDate = findValueCI(g1, ['MFGDT'], '');
  const expDate = findValueCI(g1, ['EXPDT'], '');
  const specification = findValueCI(g1, ['SPEC', 'SPEC1'], '');
  const packSize = findValueCI(g1, ['PACK', 'PACK1'], '');
  const releaseQty = findValueCI(g1, ['RELESEQTY'], '') + ' ' + findValueCI(g1, ['RELEASEUOM'], '');
  
  // Extract categorized test data
  const criticalParameters: CriticalParameter[] = [];
  const identificationTests: IdentificationTest[] = [];
  const relatedSubstances: RelatedSubstance[] = [];
  const assayResults: AssayResult[] = [];
  
  let description = '';
  let sterility: TestParameter | undefined;
  let uniformityOfVolume: TestParameter | undefined;
  let capping: TestParameter | undefined;
  
  const testGroups = getTestGroups(g1Data);
  
  for (const group of testGroups) {
    const groupName = findValueCI(group as Record<string, unknown>, ['PROTEST'], '');
    const groupCategory = classifyTest(groupName);
    const details = getTestDetails(group);
    
    for (const detail of details) {
      if (!detail || typeof detail !== 'object') continue;
      const dRecord = detail as Record<string, unknown>;
      
      const testName = findValueCI(dRecord, ['PROTEST1'], '');
      const limits = findValueCI(dRecord, ['LIMITS1'], '');
      const result = findValueCI(dRecord, ['RESULT'], '');
      
      if (!testName || testName === '.') continue;
      
      let category = classifyTest(testName);
      // Override category based on group title if necessary
      if (groupCategory === 'related_substances') category = 'related_substances';
      if (groupCategory === 'assay' && category === 'other') category = 'assay';
      if (groupCategory === 'identification' && category === 'other') category = 'identification';

      const complies = checkCompliance(result, limits);
      
      switch (category) {
        case 'description':
          description = result;
          break;
          
        case 'identification':
          // Parse compound from test name (e.g., "IDENTIFICATION BY HPLC DORZOLAMIDE")
          const idMatch = testName.match(/identification\s*(?:by\s*)?(\w+)?\s*(.+)?/i);
          const method = idMatch?.[1] || '';
          const compound = idMatch?.[2] || testName.replace(/identification/gi, '').trim();
          
          identificationTests.push({
            compound: compound || 'General',
            method: method.toUpperCase(),
            specification: limits,
            result,
            complies,
          });
          break;
          
        case 'sterility':
          sterility = { srNo: 0, name: testName, limits, result, complies };
          criticalParameters.push({ name: testName, limit: limits, result, complies });
          break;
          
        case 'uniformity':
          uniformityOfVolume = { srNo: 0, name: testName, limits, result, complies };
          criticalParameters.push({ name: testName, limit: limits, result, complies });
          break;
          
        case 'capping':
          capping = { srNo: 0, name: testName, limits, result, complies };
          criticalParameters.push({ name: testName, limit: limits, result, complies });
          break;
          
        case 'related_substances':
          // Handle Related Substances section - captures impurity data
          // Test name might be a compound header (like "DORZOLAMIDE" or "TIMOLOL")
          // or an individual impurity (like "Dorzolamide impurity B")
          
          // Check if result contains multiple impurity entries (multi-line format)
          if (result.includes(':') && (result.includes('\n') || result.includes(':'))) {
            // Multi-line impurity results format: "Impurity B : ND\nImpurity D : ND\n..."
            const lines = result.split('\n').filter(l => l.trim());
            
            // Add a grouping entry for the compound header
            if (!isRelatedSubstanceTest(testName, '')) {
              // This is a compound header like "DORZOLAMIDE" or "TIMOLOL"
              // We'll prefix impurities with this compound name
              const compoundHeader = testName.toUpperCase().trim();
              
              for (const line of lines) {
                const impurityMatch = line.match(/(.+?)\s*:\s*(.+)/);
                if (impurityMatch) {
                  const impurityName = impurityMatch[1].trim();
                  const impurityResult = impurityMatch[2].trim();
                  
                  // Parse limit from the limits field if present
                  const limitForImpurity = limits.split('\n')
                    .find(l => l.toLowerCase().includes(impurityName.toLowerCase()))
                    || limits.split('\n')[0] 
                    || limits;
                  
                  relatedSubstances.push({
                    compound: `${compoundHeader}: ${impurityName}`,
                    limit: limitForImpurity.trim(), 
                    result: impurityResult,
                    complies: impurityResult.toUpperCase().includes('ND') || 
                              impurityResult.toUpperCase().includes('NOT DETECTED') ||
                              !impurityResult.toUpperCase().includes('FAIL'),
                  });
                }
              }
            } else {
              // Individual impurity test line
              for (const line of lines) {
                const impurityMatch = line.match(/(.+?)\s*:\s*(.+)/);
                if (impurityMatch) {
                  relatedSubstances.push({
                    compound: impurityMatch[1].trim(),
                    limit: limits, 
                    result: impurityMatch[2].trim(),
                    complies: impurityMatch[2].toUpperCase().includes('ND') || 
                              impurityMatch[2].toUpperCase().includes('NOT DETECTED') ||
                              !impurityMatch[2].toUpperCase().includes('FAIL'),
                  });
                }
              }
            }
          } else {
            // Single impurity result or simple entry
            relatedSubstances.push({
              compound: testName,
              limit: limits,
              result: result,
              complies,
            });
          }
          break;
          
        case 'assay':
          // Handle specific compound assay - ONLY actual assay percentage data
          // Skip if this looks like impurity data
          if (isRelatedSubstanceTest(testName, result)) {
            // This is impurity data, add to related substances instead
            relatedSubstances.push({
              compound: testName,
              limit: limits,
              result: result,
              complies,
            });
            break;
          }
          
          if (testName !== '.' && !testName.toUpperCase().startsWith('ASSAY')) {
            // Only add if this is actual assay data (has % result)
            if (isAssayData(testName, result)) {
              const limitMatch = limits.match(/(\d+\.?\d*)\s*%?\s*to\s*(\d+\.?\d*)\s*%?/i);
              
              // Use proper pharmaceutical naming: SALT E.Q. BASE
              const properCompoundName = formatAssayCompoundName(testName);
              
              assayResults.push({
                compound: properCompoundName,
                limitMin: limitMatch ? `${limitMatch[1]}%` : '',
                limitMax: limitMatch ? `${limitMatch[2]}%` : '',
                specification: limits, // Full specification text (may include w/v range)
                result,
                resultAlt: result.includes('\n') ? result.split('\n')[1]?.trim() : undefined,
                complies,
              });
            }
          }
          break;
          
        case 'ph':
          criticalParameters.push({ name: 'pH', limit: limits, result, complies });
          break;
          
        default:
          // Check if this is an assay sub-item based on content if category is still other
          // But FIRST check if it's impurity data - if so, add to relatedSubstances
          if (isRelatedSubstanceTest(testName, result)) {
            relatedSubstances.push({
              compound: testName,
              limit: limits,
              result: result,
              complies,
            });
            break;
          }
          
          // Only add to assay if it's actual assay data with % results
          if (isAssayData(testName, result)) {
            const limitMatch = limits.match(/(\d+\.?\d*)\s*%?\s*to\s*(\d+\.?\d*)\s*%?/i);
            
            // Use proper pharmaceutical naming: SALT E.Q. BASE
            const properCompoundName = formatAssayCompoundName(testName);
            
            assayResults.push({
              compound: properCompoundName,
              limitMin: limitMatch ? `${limitMatch[1]}%` : '',
              limitMax: limitMatch ? `${limitMatch[2]}%` : '',
              specification: limits, // Full specification text (may include w/v range)
              result,
              resultAlt: result.includes('\n') ? result.split('\n')[1]?.trim() : undefined,
              complies,
            });
          }
          break;
      }
    }
  }
  
  // Get QA info
  const qaData = getQAFooter(rootData);
  const analystName = findValueCI(g1, ['ANALYSTNAME'], '');
  const analystDate = findValueCI(g1, ['ANLDATE', 'ANALIST_DATE'], '');
  
  return {
    batchNumber,
    arNumber,
    testNumber,
    testDate,
    productName,
    productCode,
    genericName,
    description,
    manufacturer,
    mfgLicenseNo,
    batchSize,
    mfgDate,
    expDate,
    specification,
    packSize,
    releaseQty,
    criticalParameters,
    identificationTests,
    relatedSubstances,
    assayResults,
    sterility,
    uniformityOfVolume,
    capping,
    remarks: findValueCI(g1, ['FGRMK'], ''),
    analystName,
    analystDate,
    qaData,
    status: findValueCI(g1, ['STATUS'], ''),
  };
}

// ============================================
// Main Parser Function
// ============================================

export interface COAParseResult {
  success: boolean;
  data?: COARecord;
  stage?: COAStage;
  errors: string[];
  warnings: string[];
}

export async function parseCOAXml(
  xmlContent: string,
  filename: string
): Promise<COAParseResult> {
  const errors: string[] = [];
  const warnings: string[] = [];
  
  console.log(`parseCOAXml called for file: ${filename}, content length: ${xmlContent.length}`);

  try {
    // Detect stage (works on original content for accuracy)
    const detected = detectStage(xmlContent, filename);
    const stage = detected.stage;
    
    // Heal XML before parsing
    const healedXml = healXmlContent(xmlContent);
    
    // Parse XML with appropriate parser based on file size
    // For large files (>50MB), use fast-xml-parser to avoid buffer offset errors
    let result: any;
    const fileSizeBytes = Buffer.byteLength(healedXml, 'utf-8');
    
      console.log(`Starting parsing.. Size: ${fileSizeBytes}`);
      if (fileSizeBytes > 50 * 1024 * 1024) {
        console.log(`⚠️ Using fast-xml-parser for large COA file (${(fileSizeBytes / 1024 / 1024).toFixed(1)}MB)`);
        
        // Use fast-xml-parser for large files
        const parser = new XMLParser({
          ignoreAttributes: false,
          trimValues: false,
          parseAttributeValue: false,
        });
        
        try {
            result = parser.parse(healedXml);
            console.log(`✅ Large file parsed successfully with fast-xml-parser`);
        } catch (parseErr) {
            console.error('Fast-XML-Parser failed:', parseErr);
            throw parseErr;
        }

      } else {
        // Use xml2js for smaller files (maintains backward compatibility)
        console.log(`Using xml2js for smaller file`);
        result = await parseStringPromise(healedXml, {
          explicitArray: false,
          ignoreAttrs: false,
          trim: false, // IMPORTANT: Keep false to preserve newlines and whitespace in multi-line data like LIMITS1
          normalize: false, // IMPORTANT: Keep false to preserve newlines in multi-line data like LIMITS1
          normalizeTags: false,
        });
      }
    
    if (!result) {
      return {
        success: false,
        errors: ['Failed to parse XML: Empty result'],
        warnings,
      };
    }
    
    // Find root element and G_1 data
    const rootKey = Object.keys(result)[0];
    const rootData = result[rootKey] || result;
    const g1Data = getG1Data(rootData) || rootData;
    
    // Generate content hash
    const contentHash = crypto.createHash('md5').update(xmlContent).digest('hex');
    
    // Extract stage-specific data
    let bulkData: BulkStageData | undefined;
    let finishData: FinishStageData | undefined;
    let batchNumber: string;
    let arNumber: string;
    let productName: string;
    let productCode: string;
    let genericName: string;
    let manufacturer: string;
    
    if (stage === 'BULK') {
      bulkData = extractBulkData(g1Data, rootData);
      batchNumber = bulkData.batchNumber;
      arNumber = bulkData.arNumber;
      productName = bulkData.productName;
      productCode = bulkData.productCode;
      genericName = bulkData.genericName;
      manufacturer = bulkData.manufacturer;
      
      // Validation warnings
      if (!batchNumber) warnings.push('Missing batch number');
      if (!arNumber) warnings.push('Missing AR number');
      if (bulkData.testParameters.length === 0) warnings.push('No test parameters found');
      
    } else {
      finishData = extractFinishData(g1Data, rootData);
      batchNumber = finishData.batchNumber;
      arNumber = finishData.arNumber;
      productName = finishData.productName;
      productCode = finishData.productCode;
      genericName = finishData.genericName;
      manufacturer = finishData.manufacturer;
      
      // Validation warnings
      if (!batchNumber) warnings.push('Missing batch number');
      if (!arNumber) warnings.push('Missing AR number');
      if (finishData.assayResults.length === 0) warnings.push('No assay results found');
    }
    
    const record: COARecord = {
      batchNumber,
      stage,
      arNumber,
      productName,
      productCode,
      genericName,
      manufacturer,
      bulkData,
      finishData,
      sourceFile: filename,
      uploadedAt: new Date(),
      contentHash,
      parsingStatus: warnings.length > 0 ? 'partial' : 'success',
      parsingWarnings: warnings.length > 0 ? warnings : undefined,
    };
    
    return {
      success: true,
      data: record,
      stage,
      errors,
      warnings,
    };
    
  } catch (error) {
    return {
      success: false,
      errors: [`Parse error: ${error instanceof Error ? error.message : 'Unknown error'}`],
      warnings,
    };
  }
}

/**
 * Parse multiple COA XML files
 */
export async function parseMultipleCOAs(
  files: Array<{ content: string; filename: string }>
): Promise<{
  success: boolean;
  records: COARecord[];
  processed: number;
  failed: number;
  errors: string[];
}> {
  const records: COARecord[] = [];
  const allErrors: string[] = [];
  let failed = 0;
  
  for (const file of files) {
    const result = await parseCOAXml(file.content, file.filename);
    
    if (result.success && result.data) {
      records.push(result.data);
    } else {
      failed++;
      allErrors.push(`${file.filename}: ${result.errors.join(', ')}`);
    }
  }
  
  return {
    success: failed === 0,
    records,
    processed: files.length,
    failed,
    errors: allErrors,
  };
}
